(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{372:function(e,t,s){"use strict";s.r(t);var n=s(45),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"image-tagging-rollbacks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#image-tagging-rollbacks"}},[e._v("#")]),e._v(" Image tagging rollbacks")]),e._v(" "),s("p",[e._v("While preparing your docker builds and releases its a good idea to tag your images. Digger uses a default tag of "),s("code",[e._v(":latest")]),e._v(" but this means that to rollback to a previous version of your code you would need to rebuild that tag or branch.")]),e._v(" "),s("p",[e._v("With the digger cli you can specify tags in the cli. you need to do that for your build-push-release cycles.")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("dg env build --tag v1\ndg env push --tag v1\ndg env release --tag v1\n")])])]),s("p",[e._v("This way you can trigger a release for a previous version by passing the "),s("code",[e._v("v1")]),e._v(" tag. You can also use the same tags for a CI/CD setting. For example, in a Github Action, you can trigger the action everytime a version tag is pushed:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('name: Digger CI\non:\n  push:\n    tags:\n      - \'v*\' # Push events to matching v*, i.e. v1.0, v20.15.10\n\njobs:\n  get_tag_version:\n    runs-on: ubuntu-16.04\n    outputs:\n      tag_version: ${{ steps.get_tag.outputs.VERSION }}\n      stage: ${{ steps.get_stage.outputs.STAGE }}\n    steps:\n    - name: Set the tag version\n      id: get_tag\n      run: echo ::set-output name=VERSION::$(echo $GITHUB_REF | cut -d / -f 3)\n\n\n  build-push-release:\n    runs-on: ubuntu-16.04\n    needs:\n      - get_tag_version\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v1\n\n    - name: Configure AWS credentials\n      uses: aws-actions/configure-aws-credentials@v1\n      with:\n        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\n        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n        aws-region: eu-west-1\n\n    - name: Set up Python 3.8\n      uses: actions/setup-python@v2\n      with:\n        python-version: \'3.8\'\n\n    - name: Build and push and release\n      env:\n        DIGGER_TOKEN: ${{ secrets.DIGGER_TOKEN }}\n        DIGGER_AWS_KEY: ${{ secrets.DIGGER_AWS_KEY }}\n        DIGGER_AWS_SECRET: ${{ secrets.DIGGER_AWS_SECRET }}\n        BACKEND_ENDPOINT: "https://backend.digger.dev"\n        WEBAPP_ENDPOINT: "https://app.digger.dev"\n      run: |\n        export TAG_VERSION=${{needs.get_tag_version.outputs.tag_version}} \n\n        # Install diggercli\n        pip install --upgrade git+https://github.com/diggerhq/cli@master\n\n        echo "> Building docker image"\n        dg env build stage --service svc1 --tag $TAG_VERSION\n        echo "> Pushing docker image to ECR"    \n        dg env push stage --service svc1 --tag $TAG_VERSION --aws-key "$DIGGER_AWS_KEY" --aws-secret "$DIGGER_AWS_SECRET"\n        echo "> Releasing"    \n        dg env push release --service svc1 --tag $TAG_VERSION --aws-key "$DIGGER_AWS_KEY" --aws-secret "$DIGGER_AWS_SECRET"\n\n\n')])])]),s("p",[e._v("In the above snippet we listen for changes to changes in a tag push and use the same tag to build and push with "),s("code",[e._v("dg")]),e._v(". This means that to rollback a previous version one can re-run a previous workflow.")])])}),[],!1,null,null,null);t.default=a.exports}}]);