(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{376:function(e,t,r){"use strict";r.r(t);var a=r(45),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"write-your-own-terraform"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#write-your-own-terraform"}},[e._v("#")]),e._v(" Write your own Terraform")]),e._v(" "),r("p",[e._v("Digger does not limit you to the buttons of its UI and commands of its CLI. Every team at some point needs to build something unique to their business. We recognise that and make it quite straightforward. Building custom infrastructure with Digger is not any harder than doing it on AWS directly - and you still benefit from centralised state and configuration management provided by Digger.")]),e._v(" "),r("p",[e._v("There are 2 ways to build custom infrastructure with Digger:")]),e._v(" "),r("ol",[r("li",[e._v("Terraform overrides in your Infrastructure Repository")]),e._v(" "),r("li",[e._v("Custom template (either fork one of Digger's standard Targets or build your own)")])]),e._v(" "),r("h2",{attrs:{id:"terraform-overrides"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#terraform-overrides"}},[e._v("#")]),e._v(" Terraform overrides")]),e._v(" "),r("p",[e._v("This is the preferred way to build custom infrastructure with Digger unless you know fur sure that you will not need the resources provided by one of the default templates (Targets) provided by Digger.")]),e._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),r("p",[e._v("Terraform overrides require a connected Infrastructure Repository. You can do that in Settings.")])]),e._v(" "),r("p",[e._v("To add ad custom Terraform, simply push a fulder named "),r("code",[e._v("_digger_custom")]),e._v(" into the "),r("code",[e._v("digger")]),e._v(" branch of your Infrastructure Repository. If you want your Terraform to be rendered in all environments, put it into the "),r("code",[e._v("_shared")]),e._v(" subfolder. And if it's for one environment only, put it into a subfolder named "),r("code",[e._v("environment-{environmentId}")]),e._v(". Digger will pick up changes from it and render your Terraform alongside the target defaults.")]),e._v(" "),r("p",[e._v("Example folder structure in the Infrastructure Repository:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("_digger_custom\n    _shared\n    environment-production\n    environment-staging\n    environment-dev\n_digger_generated\n    environment-production\n    environment-staging\n    environment-dev\ndigger.yml\ndigger-config.yml\n")])])]),r("h2",{attrs:{id:"custom-targets"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#custom-targets"}},[e._v("#")]),e._v(" Custom Targets")]),e._v(" "),r("p",[e._v("Targets are repositories with templated Terraform modules that Digger uses to generate output Terraform for your environments.")]),e._v(" "),r("p",[e._v("This is more work compared to Terraform Overrides option since you'll have to define all the infrastructure yourself. But it also gives you the most flexibility. It also makes the most sense if you are already using Terraform and want to use it with Digger.")]),e._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),r("p",[e._v("It may be easier to start out by forking one of Digger's default templates (Targets) which are open source - "),r("a",{attrs:{href:"https://github.com/diggerhq/target-fargate",target:"_blank",rel:"noopener noreferrer"}},[e._v("this one for example"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("When you have built your custom target, all you need to do is to point Digger to it when creating an environment.")]),e._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),r("p",[e._v("At the moment custom targets are only supported in the CLI but not in Web UI. You will need to create your environment with the CLI to use Custom Targets.")])]),e._v(" "),r("h3",{attrs:{id:"directory-structure"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#directory-structure"}},[e._v("#")]),e._v(" Directory Structure")]),e._v(" "),r("div",{staticClass:"custom-block warning"},[r("p",{staticClass:"custom-block-title"},[e._v("WARNING")]),e._v(" "),r("p",[e._v("Template structure is subject to changing in future versions of digger")])]),e._v(" "),r("p",[e._v("Digger Targets are not much different from standard terraform. We use jinja2 under the hood to pass configuration parameters to these templates. The flow is summarised in the visual bellow. Options flow from the digger.yml, along with additional environment options, directly into a template store in a github repository. These are used to render terraform which can be applied in the user's account.")]),e._v(" "),r("p",[e._v("The directory structure of digger templates looks similar to terraform. We run the main files under the "),r("code",[e._v("main/")]),e._v(" directory. You can see an example terraform template for fargate in this "),r("a",{attrs:{href:"https://github.com/diggerhq/target-fargate/tree/example",target:"_blank",rel:"noopener noreferrer"}},[e._v("example repository"),r("OutboundLink")],1)]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("main/\n   file1.tf\n   file2.tf\n   service.template.tf\nmodule1/\nmodule2/\nbackend_s3.template.conf\nterraform.template.tfvars\n")])])]),r("p",[e._v("Bellow the main components of a digger templates are explained:")]),e._v(" "),r("p",[r("strong",[e._v("main/")]),e._v(': The terraform apply command is run in this context and hence all the .tf files will be included in the generated infrastructure. Any file with the suffix "*.template.tf" is rendered to a .tf file before the apply and therefore you can use standard jinja template tags {{}} in these files.')]),e._v(" "),r("p",[r("strong",[e._v("service.template.tf")]),e._v(": This is a special file that is rendered multiple times for each service entry in the digger.yml file. For example, if we have two services svc1 and svc2, we will end up with service-svc1.tf and service-svc2.tf. Each file will be able to use the service options as standard {{}} jinja templates.")]),e._v(" "),r("p",[r("strong",[e._v("module/")]),e._v(": you can use either local or remote modules as supported by terraform. For local modules you can have these as sister folders and refer to them directly.")]),e._v(" "),r("h3",{attrs:{id:"using-terraform-variables"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#using-terraform-variables"}},[e._v("#")]),e._v(" Using Terraform variables")]),e._v(" "),r("p",[e._v("If you want to use terraform variables, define them in your "),r("code",[e._v("variables.tf")]),e._v(" file or elsewhere in your main/*.tf files. After that you need to assign values to these variables if they don't have a default value. You can do this in the file "),r("a",{attrs:{href:"https://github.com/diggerhq/target-fargate/blob/example/terraform.template.tfvars",target:"_blank",rel:"noopener noreferrer"}},[e._v("terraform.template.tfvars"),r("OutboundLink")],1)]),e._v(" "),r("h3",{attrs:{id:"outputs"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#outputs"}},[e._v("#")]),e._v(" Outputs")]),e._v(" "),r("p",[e._v("You can specify outputs anywhere in your template files. By convention it is nice to have all template outputs in a file called "),r("code",[e._v("outputs.tf")]),e._v(". All terraform outputs will be exposable after an "),r("code",[e._v("env apply")]),e._v(" command. To show terraform outputs for an environment, you can run "),r("code",[e._v("dg env describe env_name")])]),e._v(" "),r("h3",{attrs:{id:"mapping-outputs-to-environment-variables"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mapping-outputs-to-environment-variables"}},[e._v("#")]),e._v(" Mapping outputs to Environment Variables")]),e._v(" "),r("p",[e._v("Any output which starts "),r("code",[e._v("DGVAR_")]),e._v(" prefix will be mapped to an environment variable on release.")]),e._v(" "),r("h3",{attrs:{id:"mapping-outputs-to-secrets"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mapping-outputs-to-secrets"}},[e._v("#")]),e._v(" Mapping outputs to secrets")]),e._v(" "),r("p",[e._v("To integrate with Parameter store secrets, create an entry of the secret value and then output the value of it using "),r("code",[e._v("DGVAR_")]),e._v(" prefix as mentioned above. Here is an example: "),r("a",{attrs:{href:"https://github.com/diggerhq/target-fargate/blob/example/main/database.template.tf#L43",target:"_blank",rel:"noopener noreferrer"}},[e._v("database password"),r("OutboundLink")],1),e._v(" in parameter store mapped to "),r("a",{attrs:{href:"https://github.com/diggerhq/target-fargate/blob/example/main/outputs.template.tf#L40",target:"_blank",rel:"noopener noreferrer"}},[e._v("outputs"),r("OutboundLink")],1),e._v(" using its arn value:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('resource "aws_ssm_parameter" "database_password" {\n    name = "${var.app}.${var.environment}.rds.database_password"\n    value = local.database_password\n    type = "SecureString"\n}\n\n#...\n\n# to output a secret, simply output the ARN value of a parameter store\noutput "DGVAR_POSTGRES_PASSWORD" {\n    value = aws_ssm_parameter.database_password.arn\n    sensitive = true\n}\n')])])]),r("h3",{attrs:{id:"a-note-on-unique-naming"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#a-note-on-unique-naming"}},[e._v("#")]),e._v(" A note on unique naming")]),e._v(" "),r("p",[e._v("Some resources such as S3 buckets have to be unique globally. In addition, we want to avoid having naming conflicts of resources such as ECS clusters.")]),e._v(" "),r("p",[e._v("In Digger, project names are unique globally. Therefore if you want to gaurantee unique names of your resources across environments is to use project_name_environment_name patterns. With that said, many terraform resources also support a name_prefix attribute which gaurantee uniqueness. It is good to make use of this name_prefix attribute to avoid problems since in this case terraform will gaurantee a unique resource on your behalf:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('resource "aws_s3_bucket" "b" {\n  bucket_prefix = "my-dg-test-bucket"\n  acl    = "private"\n}\n')])])])])}),[],!1,null,null,null);t.default=o.exports}}]);